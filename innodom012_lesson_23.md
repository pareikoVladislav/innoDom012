<!-- TOC -->
* [**Client & Server, HTTP, DNS**](#client--server-http-dns)
* [**DNS**](#dns)
* [**IP**](#ip)
* [**IPv4**](#ipv4-)
* [**IPv6**](#ipv6-)
* [**OSI**](#osi)
* [**HTTP**](#http)
* [**CORS**](#cors-)
* [**Tokens**](#tokens)
  * [**Authentication Authorisation**](#authentication-authorisation-)
  * [**Sessions**](#sessions-)
* [**CSRF**](#csrf-)
* [**JWT**](#jwt-)
  * [**Аутентификация с использованием JWT**](#аутентификация-с-использованием-jwt-)
* [**Microservices and monoliths**](#microservices-and-monoliths)
  * [**monoliths**](#monoliths-)
  * [**Microservices**](#microservices-)
<!-- TOC -->

# **Client & Server, HTTP, DNS**

Есть такая штука на ПК (и много где ещё), как **процесс** (выполнение чего-то)                                           

По научному, процесс - это экземпляр программы. Так же как и в питоне у нас                                         
есть классы и их экземпляры, так и тут у нас есть экземпляры программ, процессы.                                        

Есть такая штука, как проблема меэпроцессорного общения. Дело в том, что процессы                                        
между собой не умеют общаться. Допустим вы открываете приложение для обработки                                         
видео, и приложение для просмотра видео. Вы не сможете передать что-то из первого                                       
приложения во второе.                                                     

Это проблема процессов. Процессы изолированы друг от друга и не умеют общаться друг с                                    
другом.                                                        

В целом выделить можно два способа передать информацию между процессами:                                                
* Сохранить на жёсткий диск одним процессом, прочитать другим процессом. (больше                                        
проблем, чем преимуществ)                                                     
* Занять какой-то порт.                                                     

Порт - нейкий интерфейс, через который процессы могут общаться между собой и передавать                                  
информацию.                                              
Один процесс может занять порт (порт принимающего процесса всегда указывается). Такой                                       
порт, который занимает порт и начинает его "слушать" называется - **сервер**                                             

Тот процесс, который отсылает информацию на этот сервер, называется **клиентом**.                                        
**Клиент** так же занимает порт, но это не какой-то специальный порт уже, а просто любой                                   
свободный.                                                           

Получается, что наши процессы могут передавать информацию друг между                                                
другом при помощи портов.  Процесс-сервер постоянно, в цикле сидит и слушает порт                                              
может там пришло ему чего. А процесс-клиент эти данные отсылает на указанный порт.                                       
Данные же пересылаются посредством байтов (10010111010010)                                           

Преимущество такого подхода в том, что по факту нам не обязательно, чтобы оба этих                                      
процесса находились на одной машине. Главное - чтобы они знали адрес компьютера друг                                      
друга внутри их сети.

Сеть - простым языком это соединение интерфейсов разных компьютеров между собой.                                           
Информация в ней передаётся от порта к порту, при этом если мы знаем куда нужно                                         
что-то отправить, то мы можем отправлять данные не только на своём компьютере, но                                            
и на разных компьютерах.                                                              

Система становится сложнее, когда добавляется новое устройство. У нас добавляется новый игрок,                                   
который будет следить за тем, что и кому передать - маршрутиризатор(роутер\модем).                                                                  

Когда мы к модему подключаем какой-то компьютер, модем придумывает этому компьютеру адрес                                              
Если подключение идёт в одной сети, просто у себя же дома к своему же компухтеру, то                                          
все адреса всех ПК у нас будут начинаться с `192.168._._` такой адрес называется **внутренним**                                           

У всех ПК таким образом будет свой персональный адрес. Когда мы делаем запрос с одного                                       
из ПК, то как только наш модем увидит то самое первичное совпадение по адресу `192.168._._`                                          
то поймёт, что искать нужно будет именно в локальном кругу.                                             

Так же, помимо адреса, мы прописываем и порт, какому процессу необходимо отдать наши данные.                                        

Как у наших компьютеров есть внутренний IP адресс, так и у роутеров есть свой                                              
внешний IP адресс.

Так же, как и соединение через провода, работает и `wi-fi`. По факту это всё ещё                                          
соединение на физическом уровне.                                                                     

Когда мы, допустим, с одного компьютера на западе отправляем какой-то пакет данных                                          
на другой компьютер, который у нас находится, допустим, на востоке - модем принимающего                                  
компьютера будет понимать, что если вдруг придёт снаружи запрос к порту, допустим, 8000                                           
то нужно будет отправить пакет данных на внутренний адрес, где задействован порт 8000.                                    


# **DNS**

Итак, как мы уже немного поняли как примерно работает общение между разными                                              
устройствами. Как же будет что отрабатывать, когда мы, собственно, делаем запрос                                              
на какой-то сайт? Допустим на google нам нужно. Как интернет понимает, что при                                             
вводе в поисковую строку слова google мы хотим получить именно google??                                                 

Чтобы найти нужный нам **сайт**, нам нужен его **адрес**. В мире Интернета,                                                     
адресом является `IP-адрес` – **уникальная последовательность чисел**,                                                    
например, `192.0.2.1`. Но запоминать числовые адреса для каждого сайта было                                                     
бы сложно, поэтому была создана система `DNS`.                                                                                


`DNS` – это по сути **телефонная книга** Интернета. Она переводит запоминающиеся имена                                               
доменов, такие как `www.google.com`, в числовые `IP-адреса`, которые необходимы                                              
для того, чтобы браузер мог загрузить веб-страницу.                                                 


**Принцип работы DNS**                                                 

Когда вы **вводите адрес** веб-сайта в браузер, он **отправляет запрос** к `DNS`-серверу.                                                 
`DNS`-сервер **ищет соответствующий IP-адрес** для запрошенного имени домена.                                                  
Как только `IP`-адрес найден, ваш браузер **использует его для доступа** к                                                  
серверу веб-сайта и загрузки страницы.                                                 


---

**Виды Доменов**                                                       

* `Top-Level Domains` (`TLDs`): Это самый высокий уровень в иерархии доменных                                                        
имен, например `.com`, `.org`, `.net`.                                                       
* `Second-Level Domains`: Это имена, которые вы обычно запоминаете, как                                                        
`google` в `google.com`.                                                       
* `Subdomains`: Это дополнительные уровни, используемые для организации                                                        
различных частей сайта, например `maps.google.com`.                                                       

Без `DNS` нам пришлось бы запоминать сложные числовые адреса каждого веб-сайта.                                                        
Это было бы не только неудобно, но и почти невозможно для большинства                                                        
пользователей. `DNS` делает Интернет более доступным и удобным, позволяя нам                                                        
использовать простые и запоминающиеся имена для поиска веб-сайтов.                                                       

---

# **IP**

Для полноты картины давайте немного поговорим о том, что такое                                                
`IP-адреса` и чем отличаются их версии.                                                

`IP-адрес` – это **уникальный идентификатор**, присваиваемый **каждому** устройству,                                                
подключенному к Интернету. Он работает похоже на почтовый адрес: чтобы                                                 
данные могли достичь правильного места назначения в огромной сети                                                 
Интернет, каждому устройству нужен свой собственный, **уникальный адрес**.                                                

`Internet Protocol (IP)` – это набор правил, определяющих, как данные                                                 
передаются через Интернет.
Существуют разные версии `IP`, самые распространенные – это `IPv4` и `IPv6`.                                                

---

# **IPv4**                                                

`IPv4` адреса состоят из **четырех чисел**, разделенных точками,                                                 
например, `192.0.2.1`.                                                

Каждое такое число может быть в пределах от 1 до 999 включительно.                                                               
Один из основных **недостатков** `IPv4` – ограниченное количество                                                
уникальных адресов. Всего доступно около `4.3 миллиарда адресов`, что                                                 
с учетом **растущего числа** устройств в Интернете становится **недостаточным**.                                                


# **IPv6**                                                

`IPv6` был разработан для решения **проблемы нехватки адресов**.                                                 
Эти адреса намного длиннее и представляют собой **шестнадцатеричные** числа,                                                
разделенные двоеточиями, например, `2001:0db8:85a3:0000:0000:8a2e:0370:7334`.                                                

**Основное преимущество** `IPv6` заключается в **количестве**                                                
уникальных адресов – оно практически неограниченно по сравнению с `IPv4`,                                                 
обеспечивая практически неисчерпаемый запас адресов для будущего роста                                                 
Интернета.                                                

Переход с `IPv4` на `IPv6` происходит **постепенно**, так как требует **значительных**                                                
изменений в инфраструктуре Интернета. Многие устройства и сервисы                                                 
уже поддерживают `IPv6`, но **полный переход займет время**.                                                


---

# **OSI**

**Протоколы передачи данных**                                                   

Все различные системы передачи данных, что мы рассмотрели (провода, wi-fi и др.)                                          
способны передавать по факту только 0 и 1, и всё на этом. У них есть своя частота                                             
(чем чаще передаются, тем чаще частота.)                                                        


В замисимости от того, на сколько сложная и запутанная структура может быть передана                                          
в наших 0 и 1 (байтах), у нас может быть семь различных уровней передачи                                                
данных.                                                    

1) **Физический уровень** занимается передачей сырых данных через                                                            
физические средства, например, кабели, оптоволокно, радиоволны.
Это как передача световых сигналов через оптоволокно или электрические                                                  
сигналы через медные провода.                                                              
2) **Канальный Уровень** На этом уровне происходит формирование данных для                                                  
передачи через физические средства и обнаружение ошибок, которые могли                                                    
возникнуть на физическом уровне.                                                                      
3) **Сетевой Уровень** как почтовая служба, которая определяет маршрут                                                 
доставки пакетов данных. Здесь решается, по какому пути данные                                                  
отправятся от источника к получателю.                                                              
Это как когда почтовый работник решает, через какие города и страны                                                      
отправить ваше письмо, каб дошло шустрее.                                                                            
4) **Транспортный Уровень** Здесь данные готовятся к передаче между                                                          
системами. Этот уровень обеспечивает правильное разделение данных на                                                        
части для отправки и сборку их в целое у получателя.                                                                       
   * **TCP (Transmission Control Protocol)**                                                

    `TCP` – это как отправка важного письма с уведомлением о доставке.                                                 
    Он гарантирует, что все пакеты данных дошли до адресата и в правильном порядке.                                                
    Перед отправкой данных `TCP` устанавливает соединение между отправителем                                                
    и получателем. Это называется "трехсторонним рукопожатием".                                                
    `TCP` идеально подходит для случаев, когда важна **точность данных**,                                                
    например, при загрузке веб-страницы или отправке электронной почты.                                                

   * **UDP (User Datagram Protocol)**                                                

    В отличие от `TCP`, `UDP` похож на отправку серии открыток без уведомления                                                 
    о доставке. Он быстр и прост, но не гарантирует доставку всех пакетов данных.                                                
    `UDP` не устанавливает соединение перед отправкой данных, что ускоряет                                                
    процесс передачи.                                                
    
    `UDP` часто используется в приложениях, где **скорость важнее точности**,                                                 
    например, в **видео** и **аудиостриминге**, **онлайн-играх**. 

5) **Сеансовый Уровень** На этом уровне устанавливаются, поддерживаются                                                  
и завершаются сеансы связи между приложениями. Это как организация встречи                                               
между двумя людьми.                                                        

6) **Уровень Представления** Этот уровень переводит данные в формат, который                                          
понимает приложение. Можно сравнить с переводчиком, который переводит язык                                              
одного человека на язык другого.                                                                      
7) **Прикладной Уровень** Самый высокий из уровней проктоколов передачи                                                 
данных. Это уровень, с которым непосредственно взаимодействуют пользователи.                                           
Здесь находятся все приложения и программы, через которые вы получаете                                                
доступ к данным.                                                        



---

# **HTTP**


Протокол прикладного уровня. На самом старте он в основном использовался                                                 
разработчиками для передачи всяких там HTML в интернет. ЧТобы красиво                                                   
всё отрисовывать на сайтиках этих ваших. Но со временем он отошёл                                              
от концепции посредника только для этого формата данных (HTML) и                                               
стал общепринятым ВЭБ протоколом. Работает на основе TCP\UDP, Данные передаёт                                                 
так же кусочками (пакетами), но если все эти кусочки объединятся                                             
вместе - мы получим полноценный объект - пакет.                                               

Этот пакет делится на 2 части: `HEAD`, `BODY`                                                        

`HEAD` -  отвечает за хранение информации (где, как, что, куда)
`BODY` - именно там наш HTML и передаётся(или же `JSON`, или что-то ещё)                                            

Нас, как будущих вэб-разработчиков интересует именно `head`. Там могут                                               
храниться наши эндпоинты, методы, статусы, мета информация(сколько объект                                                
весит, куда его забросить, какой у него формат, токены доступа и т.д.)                                               


URL - является нашим эндпоинтом, состоит из доменного имени, региона,                                                     
самого эндпоинта, параметров 

METHODS - каким образом наш эндпоинт нужно обработать. Типы запросов.                                                      
**GET**, **POST**, **PUT**, **PATCH**, **DELETE**                                                     

Вместо того, чтобы каждый раз писать для каждого эндпоинта по пять                                           
различных отвлетвлений (прочитать новости, удалить новость, обновить(частично))                                        
новость, создать новость - мы можем написать один класс-отображение, благодаря                                          
которому манипулировать этими методами, создавая определённую логику.                                                   
Будет всего один класс-отображение, в котором будут висеть различные методы.                                            
Такой подход называется **REST**.                                                                                          


**REST** (`Representational State Transfer`) - это архитектурный стиль для разработки                                                                                         
веб-сервисов. Он определяет набор правил для создания веб-сервисов, включая                                                                                         
методы **HTTP**, **URL** и **MIME**-типы.                                                                                        

**Принципы REST**:                                                                                        

Без сохранения состояния (**Stateless**): Каждый запрос от клиента к серверу                                                                                        
должен содержать всю информацию, необходимую для выполнения запроса. Сервер                                                                                         
не хранит информацию о предыдущих запросах.                                                                                        

**Клиент-сервер (Client-Server)**: Клиент (например, веб-браузер) и сервер работают                                                                                         
независимо друг от друга.                                                                                        

Единообразие интерфейса (`Uniform Interface`): **REST** использует стандартные                                                                                         
операции **HTTP** (**GET**, **POST**, **PUT**, **DELETE**), которые соответствуют операциям CRUD.                                                                                        

Без состояния ресурсов (Stateless Resources): В REST ресурсы (такие как объекты                                                                                        
в базе данных) идентифицируются URL-ами. Например, /students может                                                                                         
представлять всех студентов, а `/students/123` - конкретного студента с `ID 123`.                                                                                        

**Связь между CRUD и REST:**                                                                                        

* `Create`: соответствует методу HTTP POST                                                                                        
* `Read`: соответствует методу HTTP GET                                                                                        
* `Update`: соответствует методу HTTP PUT или PATCH                                                                                        
* `Delete`: соответствует методу HTTP DELETE Таким образом, CRUD и REST                                                                                         
тесно связаны.                                                                                        
**CRUD** определяет основные операции, которые мы можем выполнять над данными,                                                                                        
а **REST** представляет способ организации веб-сервисов вокруг этих операций,                                                                                        
используя стандартные методы и принципы веба.                                                                                        


**STATUSES** - быстрый, ёмкий и доступный способ понять, как прошёл запрос.                                                                                        

Статусов достаточно много и все они разнятся на следующие категории:                                                   

**100-199** - подсказки разного рода.                                          
**200-299** - сообщения об успешном запросе.                                          
**300-399** - перенаправляния                                          
**400-499** - ошибки клиента                                          
**500-599** - обишки сервера                                          


---

# **CORS**                                                                                    

**CORS** (`Cross-Origin Resource Sharing`) — это механизм **безопасности**, который                                           
регулирует, как веб-приложения на одном источнике (домене) могут взаимодействовать                                          
с ресурсами на другом источнике. **CORS Headers** играют ключевую роль в этом механизме.                                          

**Зачем нужны CORS Headers?**                                          
`Контроль безопасности`: **CORS** предотвращает потенциально вредоносные сайты                                           
от чтения чувствительных данных с вашего сайта. Например, если вы залогинены в                                           
банк, вредоносный сайт не сможет сделать запрос к банку и украсть вашу информацию.                                          

`Гибкость для разработчиков`: **CORS Headers** позволяют разработчикам указать,                                           
какие источники допустимы для доступа к ресурсам. Это полезно, если у вас                                          
есть публичное **API**, которое вы хотите открыть для всех, или частное **API**,                                          
доступное только для определенных доменов.                                          

**Основные CORS Headers:**                                          
* `Access-Control-Allow-Origin`: Указывает, какие домены могут получить доступ                                           
к ресурсу. Без этого заголовка браузеры блокируют запросы между доменами.                                          

* `Access-Control-Allow-Methods`: Определяет, какие HTTP-методы (GET, POST и                                           
т. д.) разрешены для использования при запросе к ресурсу.                                          

* `Access-Control-Allow-Headers`: Указывает, какие HTTP-заголовки можно                                           
использовать в запросе.                                          

* `Access-Control-Allow-Credentials`: Управляет тем, могут ли сайты передавать                                           
учетные данные, такие как куки, при запросе.                                          

**Почему без них нельзя?**                                          

Без **CORS Headers** браузеры применяют политику одного источника (`same-origin`                                          
`policy`), которая блокирует запросы к другим доменам. Это означает, что                                          
веб-приложение на одном домене не может запрашивать данные с другого                                           
домена без явного разрешения через **CORS**.                                          

**Пример:**                                          
Предположим, у вас есть веб-приложение на `example.com`, которое хочет получить                                          
данные с вашего **API** на `api.example.com`. Без настройки **CORS**, браузер                                           
заблокирует этот запрос.                                          

Если вы на сервере `api.example.com` установите заголовок `Access-Control-Allow-Origin`                                           
со значением `https://example.com`, запросы с `example.com` будут разрешены, и                                           
ваше веб-приложение сможет получить данные.                                          

**Вывод:**                                          
**CORS Headers** обеспечивают баланс между безопасностью и гибкостью, позволяя                                           
разработчикам контролировать, как их ресурсы могут быть доступны другим                                          
доменам. Без этих заголовков взаимодействие между разными доменами было бы                                           
**невозможным** из-за ограничений безопасности браузера.                                                             

---

# **Tokens**

Токен в контексте компьютерной безопасности и программирования — это небольшой                                                              
фрагмент данных, который служит символом или заместителем чего-то ещё. Он                                                             
может представлять собой разные вещи в зависимости от контекста, в                                                              
котором используется.                                                             


## **Authentication Authorisation**                                                             
В контексте аутентификации и авторизации токен — это секретный ключ, который                                                             
выдается пользователю после успешного входа в систему. Он может быть использован                                                              
для доказательства идентичности пользователя или для выполнения определенных                                                             
действий от имени пользователя.                                                             

**Примеры:**                                                             

**Токен доступа** (`Access Token`): Предоставляет доступ к определенным ресурсам                                                             
или службам. Например, `OAuth2` использует токены доступа для авторизации                                                              
третьих сторон, чтобы действовать от имени пользователя.                                                             

**Токен обновления** (`Refresh Token`): Может быть использован для получения                                                              
нового токена доступа без необходимости ввода имени пользователя и                                                              
пароля заново.                                                             


## **Sessions**                                                             

**Токен сессии** — это уникальный идентификатор, который генерируется и                                                              
отправляется пользователю при успешной аутентификации. Он затем используется                                                              
для идентификации пользователя во всех последующих запросах в рамках сессии.                                                             

**Устройства безопасности**                                                             

Физические токены, такие как смарт-карты или специализированные устройства                                                              
для двухфакторной аутентификации, также могут называться токенами. Они                                                             
хранят секретные ключи или цифровые сертификаты и могут использоваться для                                                             
аутентификации в различных системах.                                                             

**Вывод**                                                             
Токен, в общем смысле, является символическим или фактическим заместителем                                                             
некоторой информации или права. Он может быть цифровым ключом, символьным                                                             
идентификатором, физическим устройством или даже просто строкой, которая                                                             
олицетворяет или представляет что-то ещё в определенном контексте.                                                             

**Примеры из жизни**                                                             

Вот три примера из реальной жизни, которые могут служить аналогией для токена                                                             
в цифровом мире:                                                             

**Билет на поезд или самолет**: Билет служит "**токеном**", подтверждающим ваше                                                              
право на место в транспортном средстве. Как и цифровой токен, он связан                                                              
с вашей личностью (или, по крайней мере, с бронированием) и позволяет                                                             
вам получить доступ к определенной услуге, в данном случае — путешествию.                                                             

**Жетон для игровых автоматов**: Жетон в игровом автомате служит заместителем                                                              
реальных денег и даёт возможность играть в автомат. Он может быть                                                              
использован только в определенном контексте (в данном случае,                                                              
в автомате) и предоставляет доступ к определенной услуге или функции.                                                             

**Ключ от номера в гостинице**: Этот ключ (или карта-ключ в современных                                                              
гостиницах) является **физическим "токеном"**, который подтверждает ваше право                                                             
на доступ в определенный номер гостиницы. Так же как и цифровой токен                                                              
авторизации, он дает право доступа к защищенному ресурсу (в данном                                                              
случае, вашему номеру) и связан с вашей идентификацией как                                                              
гостя гостиницы.                                                             

Эти примеры иллюстрируют, как токен может служить заместителем или                                                              
символом чего-то ещё, будь то права доступа, идентификация или                                                             
даже денежные средства, в различных сценариях реального мира.

---
# **CSRF**                                                             

`CSRF (Cross-Site Request Forgery)` — это тип атаки, при которой                                                             
злоумышленник может заставить пользователя выполнить нежелательное                                                              
действие на веб-сайте, на котором он аутентифицирован. `CSRF-токен` —                                                              
это защитный механизм, который предотвращает такие атаки.                                                             

**Особенность и назначение CSRF-токена**                                                             
`CSRF-токен` уникален для каждого пользователя и сессии. Он гарантирует, что                                                             
запрос, отправленный на сервер, действительно исходит от аутентифицированного                                                              
и авторизованного пользователя, а не от злоумышленника, который пытается                                                              
воспользоваться сессией пользователя.                                                             

**Как он работает**                                                             
**Генерация токена**: Когда пользователь заходит на сайт и аутентифицируется,                                                              
сервер генерирует уникальный `CSRF-токен`. Этот токен затем вставляется в                                                              
формы на веб-странице в виде скрытого поля или добавляется в заголовки                                                             
`HTTP-запросов`.                                                             

**Хранение токена**: Токен также хранится на стороне сервера или в сессии                                                             
пользователя. Он должен оставаться секретным, чтобы злоумышленники не                                                              
могли его угадать или украсть.                                                             

**Проверка токена**: Когда пользователь отправляет запрос (например, при                                                              
отправке формы), `CSRF-токен` также отправляется на сервер. Сервер затем                                                             
сравнивает этот токен с токеном, хранящимся в сессии пользователя. Если                                                              
токены совпадают, запрос считается легитимным. Если нет — запрос отклоняется,                                                              
так как есть вероятность, что он исходит от злоумышленника.                                                             

`CSRF-токен` в **Django** и в других системах защиты не просто случайная строка,                                                              
которую можно было бы подделать. Он связан с конкретной сессией пользователя,                                                              
и сервер ожидает определённого значения для каждой сессии. Вот почему                                                             
просто вставить придуманный токен не сработает:                                                             

**Связь с Сессией**: `CSRF-токен` связан с конкретной сессией пользователя, и                                                              
сервер знает, какой токен ожидать от каждой сессии. Если злоумышленник                                                              
просто придумает токен и вставит его в куки и форму, сервер при проверке                                                              
увидит, что токен не совпадает с ожидаемым для данной сессии,                                                             
и запрос будет отклонён.                                                             

**Уникальность**: Даже если злоумышленник каким-то образом украдет токен другого                                                              
пользователя, этот токен будет связан только с сессией этого конкретного                                                              
пользователя. Использование его в другом контексте также                                                              
приведет к ошибке.                                                             

**Безопасность передачи**: Токен передается через HTTPS (если сайт                                                              
настроен соответствующим образом), что делает перехват токена                                                              
злоумышленником еще сложнее.                                                             

**Жизненный цикл**: Токены могут иметь временные ограничения, по                                                             
истечении которых они становятся недействительными.                                                             

Таким образом, механизм защиты от CSRF не просто ожидает любой токен                                                              
в куках и форме; он ожидает конкретного токена, связанного с конкретной                                                             
сессией, и проводит строгую проверку. Это делает атаки путем                                                              
подделки токена практически невозможными.                                                             

---
# **JWT**                                                             

`JWT (JSON Web Tokens)` - это компактный и самодостаточный способ передачи                                                              
информации между сторонами в формате JSON. Информация может быть подтверждена                                                              
и доверена, так как она подписана. JWT часто используется для аутентификации                                                             
и передачи информации о пользователях между клиентом и сервером.                                                             

`JWT` состоит из трёх частей:

* **Заголовок (Header)**: Определяет тип токена и используемый алгоритм                                                              
подписи, например HMAC `SHA256` или `RSA`.                                                             

* **Полезная нагрузка (`Payload`)**: Содержит утверждения (`claims`),                                                             
которые являются заявлениями о сущности (обычно пользователе) и                                                             
дополнительных данных. Некоторые из них зарезервированы и имеют                                                              
определенные названия, но вы также можете добавлять                                                              
свои утверждения.

* **Подпись (Signature)**: Чтобы создать подпись, нужно закодировать                                                              
заголовок и полезную нагрузку с помощью `Base64Url` и объединить их                                                              
точкой, затем подписать полученную строку секретным ключом.

## **Аутентификация с использованием JWT**                                                             

1) Пользователь вводит свои учетные данные (логин и пароль).                                                               
2) Сервер проверяет учетные данные и при успешной проверке создает                                                               
JWT, подписанный своим секретным ключом.                                                               
3) JWT отправляется пользователю.                                                               
4) Пользователь сохраняет токен и отправляет его с каждым следующим запросом.                                                               
5) Сервер проверяет подпись токена, чтобы гарантировать его                                                               
целостность и аутентичность.                                                               


**Вопросы и моменты, на которые стоит обратить внимание:**                                                               

**Безопасность**: Нельзя хранить важные конфиденциальные данные в JWT, так как                                                               
содержимое может быть прочитано. Шифрование может использоваться                                                                
для скрытия содержимого.                                                               

**Срок годности**: JWT может иметь срок годности, что является хорошей                                                               
практикой для снижения рисков безопасности.                                                               

**Место хранения токена**: Токены могут быть уязвимыми к краже, поэтому                                                                
их хранение и передача требуют осмотрительности.                                                               

**Отзыв токенов**: JWT не имеет встроенного механизма отзыва, поэтому,                                                               
если токен скомпрометирован, его нельзя просто "отозвать". Возможные решения                                                                
могут включать использование коротких сроков жизни токена                                                               
и обновление токенов.                                                               

**Размер**: JWT может быть относительно большим по сравнению с другими                                                                
токенами, поэтому нужно об этом помнить, особенно если используете                                                                
их в URL или заголовках.                                                               

`JWT` предоставляет мощный инструмент для работы с аутентификацией и                                                                
авторизацией, но его нужно использовать осторожно и осознанно,                                                                
особенно в отношении безопасности.                                                               

`JWT` (`JSON Web Token`) является стандартизированным способом представления                                                                
заявлений между двумя сторонами. Главная особенность JWT заключается в                                                                
том, что он может быть самодостаточным, то есть содержать всю необходимую                                                               
информацию в себе, и эта информация может быть верифицирована                                                                
и надёжно зашифрована.                                                               

При получении токена сервер может декодировать его и проверить подпись, используя                                                                
тот же секретный ключ, что и при создании токена. Если подпись не совпадает,                                                                
это означает, что токен был изменён, и он будет отклонён.                                                               

Таким образом, можно сказать, что JWT похож на контрольную сумму в том смысле,                                                               
что он предоставляет способ проверки целостности данных. Но в отличие от простой                                                                
контрольной суммы, JWT также может содержать информацию, верифицировать                                                                
отправителя, и быть защищённым от подделки благодаря                                                                
использованию криптографической подписи.

Давайте рассмотрим шаги работы клиента и сервера с JWT токеном, начиная с                                                                
аутентификации пользователя и заканчивая использованием токена                                                                
для защиты конечных точек (endpoints).                                                               

**Аутентификация Пользователя**:                                                               

1) **Клиент отправляет** учетные **данные** пользователя (например, имя                                                                
пользователя и пароль) на сервер.                                                               

2) **Сервер проверяет** учетные **данные**, и если они действительны, генерирует JWT токен.                                  

3) **В заголовке** токена указывается **алгоритм подписи** (например, `HS256`).                                                               

4) В **полезной нагрузке** могут быть указаны различные утверждения, такие как                                                                
**идентификатор пользователя**, **роли** и другие атрибуты.                                                               

5) **Сервер подписывает** токен с использованием **секретного ключа**.                                                               

6) **Токен отправляется обратно** клиенту, который сохраняет его, обычно в                                                                
заголовке **Authorization** или в куках.                                                               
---

**Использование Токена**:                                                               

1) **Клиент делает запрос** к защищенному ресурсу на сервере, включая `JWT`                                                               
токен в заголовке **Authorization**.                                                               

2) **Сервер извлекает токен** и **проверяет его подпись** с использованием того                                                               
же секретного ключа, который использовался для создания подписи.                                                               

3) **Если подпись недействительна** (например, токен был изменен или                                                               
подделан), **сервер отклоняет запрос**.                                                               

4) **Если подпись действительна**, сервер затем может **проверить дополнительные**                                                               
утверждения в токене, такие как **срок годности**.                                                               

5) **Сервер извлекает информацию** о пользователе из полезной нагрузки токена                                                                
(например, идентификатор пользователя) и использует ее для                                                                
выполнения операции, если все проверки прошли успешно.                                                               

6) **Ответ возвращается клиенту.**                                                               


**Обновление Токена (при необходимости):**                                                               

Если токен имеет **ограниченный срок действия**, клиент может понадобиться                                                               
**обновить его**.                                                               
Это **может быть** выполнено с помощью **отдельного обновляемого токена** или                                                               
другого механизма, зависящего от конкретной реализации.                                                               


**Логаут (при необходимости):**                                                               

Клиент может **удалить** сохраненный `JWT` токен, чтобы выполнить операцию                                                                
**выхода из системы**.                                                               
В некоторых системах сервер также может сохранять "**черный список**"                                                                
отозванных токенов, чтобы предотвратить их дальнейшее использование.                                                               
Этот процесс охватывает большую часть жизненного цикла `JWT` в типичном                                                                
взаимодействии клиент-сервер. На каждом этапе могут существовать                                                                
дополнительные проверки и шаги в зависимости от конкретных                                                                
требований системы.                                                               


**Примеры из жизни**
Вот три аналогии из реальной жизни, которые могут напомнить работу                                                               
с JWT токеном:                                                               

1) **Паспорт или Водительское Удостоверение**: Ваш паспорт или водительское                                                                
удостоверение содержит **личную информацию** и фотографию, а также                                                                
подписаны уполномоченным органом (например, правительством). Когда                                                                
вы предъявляете его в аэропорту или при остановке полицией, они                                                                
могут проверить его подлинность и определить вашу личность. Это похоже                                                               
на то, как сервер проверяет подпись `JWT токена` и извлекает                                                                
информацию о пользователе из полезной нагрузки.                                                               

2) **Билет на Концерт или Мероприятие**: Когда вы покупаете билет на концерт,                                                               
он может содержать **уникальный штрих-код** или `QR-код`, который отражает                                                               
информацию о месте, дате и времени мероприятия. Входной контроль сканирует                                                                
ваш билет и проверяет информацию в базе данных, чтобы убедиться, что                                                               
билет действителен. Это схоже с тем, как `JWT токен` содержит утверждения                                                                
о пользователе и сервер проверяет их при каждом запросе.                                                               

3) **Запечатанный Конверт с Подписью**: Если вы получаете запечатанное письмо с                                                                
подписью отправителя на печати, вы можете быть уверены в том, что письмо не                                                               
было вскрыто или изменено после того, как его запечатали. Сервер,                                                               
который проверяет подпись `JWT токена`, работает аналогичным образом,                                                                
проверяя, что токен не был изменен с момента его создания.
---

# **Microservices and monoliths**

Микросервисы и монолиты — это два подхода к архитектуре программного                                                 
обеспечения, и они имеют свои сильные и слабые стороны.                                       

## **monoliths**                                                                                      

**Описание:**                                       

**Единое Приложение**: В монолитной архитектуре всё приложение строится                                       
как один крупный блок кода.                                       
**Общая База Данных**: Обычно используется одна база данных для всего                                        
приложения.                                       


**Преимущества:**                                       

**Простота Разработки**: Все части приложения в одном месте, поэтому                                        
разработка и тестирование часто проще.                                       
**Эффективное Использование Ресурсов**: Все части приложения работают                                        
в одном процессе, что может повысить эффективность.                                       

**Недостатки:**

**Масштабирование**: Если вам нужно масштабировать определенный компонент,                                        
вы должны масштабировать весь монолит.                                       
**Жёсткость**: Изменения в одной части могут затрагивать всю систему, что                                        
может затруднить обновления и поддержание кода.                                                           


## **Microservices**                                                                                                            

**Описание**:                                                           

Разделение на Сервисы: Приложение разбито на множество небольших,                                                            
автономных сервисов. Каждый микросервис выполняет конкретную                                                            
задачу или функцию.                                                           

Независимость: Микросервисы могут разрабатываться, тестироваться,                                                           
развертываться и масштабироваться независимо друг от друга.                                                           


**Преимущества**:

Гибкость и Масштабирование: Можно легко масштабировать или изменить                                                            
отдельные части системы.                                                           

Технологическая Агностика: Разные микросервисы могут использовать разные                                                            
технологии, языки программирования и базы данных.                                                           


**Недостатки**:

Сложность Управления: Управление множеством независимых сервисов                                                            
может быть сложным.                                                           
Задержки Сети: Поскольку микросервисы общаются между собой через сеть,                                                           
это может добавить дополнительную задержку.                                                           


**Пример**:
**Монолит**: Онлайн-магазин как одно большое приложение, включая каталог                                                            
продуктов, корзину, платежи и т. д.                                                           

**Микросервисы**: Тот же онлайн-магазин, но разбитый на отдельные сервисы:                                                            
один для каталога, один для корзины, один для платежей и так далее.                                                           

**Заключение**:
Монолиты лучше подходят для небольших или простых проектов, где преимущества                                                           
одной кодовой базы перевешивают недостатки.                                                           

Микросервисы предпочтительнее для крупных и сложных систем, где гибкость                                                            
и масштабируемость являются ключевыми факторами.                                                           

Выбор между этими двумя подходами будет зависеть от специфики проекта,                                                            
требований к нему, а также от опыта и предпочтений команды разработчиков.                                                           
---

**Правила создания микросервесного приложения**                                                         


Создание микросервисного приложения может быть сложным процессом, и                                                          
существует несколько важных принципов и правил, которыми                                                          
стоит руководствоваться:                                                         

1) **Определите Границы Сервисов**: Каждый микросервис должен иметь чётко                                                         
определенную ответственность и функциональность. **Один сервис - одна задача**.                                                         

2) **Независимость**: Микросервисы должны быть **независимы друг от друга**. Они                                                          
могут разрабатываться, развертываться и масштабироваться отдельно.                                                         

3) **Децентрализованное Управление Данными**: **Каждый микросервис** должен иметь                                                         
**собственную базу данных**, чтобы избежать связанности и                                                         
зависимости между сервисами.                                                         

4) **Автоматизация**: Применяйте автоматизацию для развертывания, мониторинга                                                          
и масштабирования сервисов. Это снизит сложность управления ими.                                                         

5) **Стандартизация Общения**: Все микросервисы должны общаться через **хорошо**                                                          
**определенные** и **стандартизированные интерфейсы**, такие как `REST` или `gRPC`.                                                         

6) **Обработка Сбоев**: Разработайте стратегии для обработки сбоев и                                                         
отказоустойчивости, так как сбои в одном сервисе не                                                         
должны влиять на другие.                                                         

7) **Мониторинг и Логирование**: Имейте систему мониторинга и логирования                                                          
для отслеживания состояния каждого микросервиса.                                                         

8) **Безопасность**: Обеспечьте надежную безопасность на уровне каждого                                                         
микросервиса, включая аутентификацию и авторизацию.                                                         

9) **Контейнеризация**: Используйте технологии контейнеризации, такие как                                                          
Docker, чтобы упростить развертывание и управление микросервисами.                                                         

10) **Сохраняйте Культуру CI/CD**: Постоянная интеграция и непрерывная доставка                                                         
(CI/CD) должны быть ключевыми компонентами вашего рабочего процесса.                                                         

11) **Документация**: Обеспечьте подробную и актуальную документацию для каждого                                                         
микросервиса, чтобы упростить сотрудничество и поддержку.                                                         

12) **Проектирование для Изменений**: Разрабатывайте микросервисы так, чтобы они                                                         
могли легко адаптироваться к изменениям требований или технологий.                                                         

13) **Рассмотрите Общие Библиотеки**: Для устранения дублирования кода рассмотрите                                                         
возможность создания общих библиотек, которые могут быть                                                         
использованы разными микросервисами.                                                         

14) **Оценивайте Сложность**: Микросервисы могут быть переусложнены для небольших                                                         
проектов. Оцените, подходит ли этот подход для вашего конкретного случая.                                                         

Соблюдение этих принципов может способствовать успешному проектированию и                                                          
внедрению микросервисного приложения, минимизируя распространенные                                                          
проблемы и сложности этого подхода.                                                         
