# **Docker-compose**                                                   

Как мы уже рассматривали на прошлом занятии, благодаря `dockerfile`\
мы можем с вами создавать свои кастомные, более точные образы для\
сборки наших приложений. На прошлом занятии мы с вами описали такой\
образ, который включал в себя базовый образ `ubuntu`, на основе которого\
разворачивалось наше приложение и база данных.

Собственно, если `dockerfile` мы прописываем для настройки образа, то контейнеры                                                  
которые будут строиться по этому образу прописываются в `docker-compose.yml` файле.                                         

Формат написания контейнеров через `docker-compose` файл мы можем использовать\
в тех случаях, когда:\
* Нам необходимо более одного контейнера в нашем приложении
* Нам вполне хватает базовых образов, на основе которых контейнер\
и будет создаваться. 


Файл `docker-compose.yml` использует формат `YAML` (`YAML Ain't Markup Language`),                                                   
который представляет собой удобный для человека формат сериализации данных.                                                   
`YAML` часто используется для конфигурационных файлов и данных, которые должны                                                   
быть легко читаемыми пользователями.                                                  


## **Core settings of docker-compose**                                      

Есть определённое количество общих настроек в этом файле, которые зачастую                                                   
прописываются там:                                           

* `version`: Указывает версию `Docker Compose` файла. Например, `version: '3'`.                                                     
Версия `Docker Compose` определяет, какие функции и форматы файла поддерживаются.                                           
По мере развития `Docker Compose` вводятся новые функции и изменения в синтаксисе,                                           
поэтому важно указывать версию, чтобы обеспечить совместимость и правильное                                            
понимание файла `Docker Compose`.                                           

* `services`: Определяет сервисы, которые необходимо запустить. Каждый сервис,                                                      
в свою очередь, может иметь множество настроек.                                                     

* `build`: Определяет параметры для сборки образа `Docker`. Может включать контекст                                                      
сборки и путь к `Dockerfile`.                                                     

* `image`: Указывает имя образа для использования или сборки.                                                     

* `ports`: Определяет порты, которые будут открыты и соединены. Например, `- "8000:8000"`                                                      
означает перенаправление порта `8000` хоста на порт `8000` контейнера.                                                     

* `volumes`: Определяет тома для хранения данных вне жизненного цикла контейнера.                                                     

* `environment`: Устанавливает переменные окружения внутри контейнера.                                                     

* `depends_on`: Определяет зависимости между сервисами, гарантируя, что                                                     
сервисы запускаются в определенном порядке.                                                     


Так же можно встретить и такие дополнительные настройки:                                      

* `networks`: Определяет сети для взаимодействия контейнеров.                                                      

* `command`: Позволяет переопределить команду по умолчанию при запуске контейнера.                                                      

* `links`: Устаревшая опция, которая позволяет связывать контейнеры без                                                       
необходимости определения сетей.                                                      

* `expose`: Открывает порты только между контейнерами, но не делает их                                                       
доступными с хоста.                                                      

* `entrypoint`: Позволяет переопределить точку входа (entrypoint) образа.                                                      


## **Compose file commands hierarchy**                                                

Структура файла `docker-compose.yml` включает в себя несколько ключевых разделов:

`version`: Верхнеуровневый параметр, указывающий версию синтаксиса `Docker Compose`.                                            

`services`: Главный раздел, под которым перечисляются все сервисы (контейнеры),                                             
которые необходимо запустить.                                            

```yaml
version: '3'
services:
  webapp:
    ...
  db:
    ...
```

Внутри каждого сервиса (`webapp`, `db` и т.д.) могут быть указаны следующие настройки:                                            

* `image` или `build`: Определяют образ, который будет использоваться для контейнера.                                            
* `ports`: Указывают настройки портов.                                            
* `volumes`: Определяют тома для хранения данных.                                            
* `environment`: Устанавливают переменные окружения.                                            
* `depends_on`: Задают зависимости от других сервисов.                                            
И другие настройки, специфичные для каждого сервиса.                                            
* `volumes`: Определяет тома, используемые в сервисах.                                            

* `networks`: Определяет сети, которые используются для взаимодействия между контейнерами.                                            

* `configs` и `secrets`: Опциональные разделы для управления конфигурациями и секретами.                                            

Эти разделы создают иерархию, в которой каждый сервис определяется своим набором                                             
параметров. Важно понимать, что параметры внутри сервиса применяются только к                                             
этому сервису, в то время как параметры вне сервисов (например, `volumes` и `networks`                                             
на верхнем уровне) относятся ко всему `Compose` проекту в целом.                                            

В зависимости от требований, или же пожеланий наших с вами \ проекта, мы можем\
создавать различные структуры с докером:

* Один главный образ Dockerfile и всё(тогда более точно его описывать, что\
именно там будет происходить)
* Один главный образ Dockerfile и много контейнеров (тогда будет использоваться\
docker-compose.yml дополнительно)
* Много разных образов для разных сервисов. Для каждого сервиса свой Dockerfile
* Один образ Dockerfile и много разных версий docker-compose.yml контейнеров:\
для тестов, для разработки, для продакшна

Сперва давайте чуть детальнее рассмотрим вариант, если нам в проекте достаточно\
локальной работы, но есть какие-то проблемы с запуском СУБД, или же нам просто\
хочется поднимать её так, чтобы проблем не было ни у кого. Для этого мы
можем описать, допустим, `compose`-файл:


```yaml
version: "3.8"

services:
  dev_db:
    image: postgres:latest
    container_name: postgres_dev
    environment:
      POSTGRES_USER: ${DB_USER_POS}
      POSTGRES_PASSWORD: ${DB_PASSWORD_POS}
      POSTGRES_DB: ${DB_NAME_POS}
    ports:
      - "54321:5432"
    volumes:
      - dev_db_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER_POS} -h localhost -d ${DB_NAME_POS}"]
      start_period: 15s
      interval: 15s
      timeout: 5s
      retries: 3


volumes:
  dev_db_data:
```

Таким образом мы сможем работать локально в нашем проекте, при этом\
база данных конкретно у нас будет отдельно в докер образе

В случае же, если нам необходимо ещё и сам проект прокинуть в контейнер,\
мы можем воспользоваться написанием кастомного образа для этого.

Сперва нужно создать и настроить **Dockerfile**

```dockerfile
FROM ubuntu:20.04

RUN apt-get update && apt-get install -y python3 python3-pip

WORKDIR /app

COPY requirements.txt /app/

RUN pip3 install -r requirements.txt

COPY . /app/

COPY /dump/todo_back.sql /docker-entrypoint-initdb.d/

CMD ["sh", "-c", "python3 manage.py makemigrations && python manage.py migrate"]
```

И уже после этого только создавать наши контейнеры, сколько их нам требуется.

```yaml
version: '3.8'

services: # описание всех сервисов(контейнеров) в рамках этого файла
  db: # Сервис для PostgreSQL
    image: postgres:latest # образ, на базе которого будет создаваться контейнер
    environment: # если необходимы значения переменных окружения - можем воспользоваться этой настройкой
      POSTGRES_USER: ${DB_USER_POS}        # Имя пользователя, берется из .env файла
      POSTGRES_PASSWORD: ${DB_PASSWORD_POS}    # Пароль, берется из .env файла
      POSTGRES_DB: ${DB_NAME_POS}          # Имя базы данных, берется из .env файла
    volumes: # специальный атрибут, позволяющий указывать где именно будут сохраняться данные
      - postgres_data:/var/lib/postgresql/data
    healthcheck: # специальный (не обязательный, но рекоммендуемый) параметр, позволяющий проверить контейнер перед запуском
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER_POS}"] # команда, которой мы "тыкаем" контейнер
      interval: 10s # определяет через какое время будет запущена первая проверка и в последствии снова через этот интервал секунд по завершении каждого пинга 
      timeout: 5s # максимальное значение в секундах, после которого попытка проверки контейнера считается неудачной
      retries: 5 # кол-во попыток запуска тестов, по истечению которых контейнер признаётся "нездоровым"
    command: ["docker-entrypoint.sh", "postgres"] # Отменяет команду по умолчанию, объявленную в образе контейнера

  webapp: # Сервис для Django приложения
    build: . # Сборка образа из текущего Dockerfile
    command: sh -c "python3 manage.py runserver 0.0.0.0:8888"
    volumes:
      - .:/app
    ports:
      - "8888:8888"
    environment:
      SECRET_KEY: ${SECRET_KEY}        # Secret key, берется из .env файла
    depends_on: # Специальная настройка, которая позволяет "остановить" запуск текущего контейнера, пока не будет поднят тот, от которого зависит этот контейнер
      db: # название контейнера, от которого, собственно, текущий контейнер и будет "зависеть"
        condition: service_healthy # специальное условие прохождения контейнера, от которого зависит текущий

volumes: # Постоянные хранилища данных, реализуемые платформой. Указываем, если хотим, чтобы при "уничтожении" контейнера данные сохранялись
  postgres_data:
```

---
