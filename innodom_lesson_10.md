# **Types of functions**

# **Generators / iterators**

**Итеративный объект** – это объект, по которому можно совершить итерацию.                                    

**Итераторы** – это функции либо конструкции языка, которые позволяют                         
проходиться по итеративным объектам.                                

Вы уже знакомы со способом прохода через цикл. Однако, если в итеративном                                       
объекте хранится много значений, тогда на помощь приходит функция                                      
`iter()` и `next()`, которые позволяют не хранить целый объект в памяти,                                           
а извлекают его и хранят только текущий элемент.                                

Когда элементы в итераторе заканчиваются, вызывается                                             
исключение `StopIteration`.                              

**Как это выглядит:**                           

```python
my_list = {"one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}
my_iter = iter(my_list)

my_iter = iter(my_list)
print(type(my_iter))
print(next(my_iter))
print(next(my_iter))
print(next(my_iter))
print(next(my_iter))
print(next(my_iter))
print(next(my_iter))
print(next(my_iter))
print(next(my_iter))
print(next(my_iter))
# print(next(my_iter))
```

Итераторы полезны, когда мы хотим выполнять итерацию через большие                                      
или бесконечные коллекции, такие как файлы, базы данных                                    
или потоки данных.                               

**Генератор** – это функция, которая позволяет делать вам свои итераторы.                            

```python
def multiple_value_generator(value):
    while value < 50:
        yield value
        value *= 2


custom_generator = multiple_value_generator(2)

print(next(custom_generator))
print(next(custom_generator))
print(next(custom_generator))
print(next(custom_generator))
print(next(custom_generator))
print(next(custom_generator))
```

Генераторы очень эффективны, когда нам нужно производить значения по                         
мере необходимости, а не все сразу. Они также помогают сэкономить                      
память, так как не требуют хранения всех значений в памяти одновременно.

Генераторы могут быть бесконечными, и их выполнение может продолжаться                          
до бесконечности. Мы можем ограничить количество итераций с помощью                         
функции `range()` или условного оператора.

Генераторы также могут быть использованы вместе с различными функциями,                           
такими как `map()`, `filter()` и `reduce()`, чтобы создавать компактный                            
и выразительный код.                           

```python
numbers = [1, 2, 3, 4, 5]

squared_numbers = map(lambda x: x**2, numbers)

def squared(n):
    for number in n:
        yield number ** 2

squared_numbers_gen = squared(numbers)
# print(list(squared_numbers_gen))  # [1, 4, 9, 16, 25]
print(next(squared_numbers_gen))
print(next(squared_numbers_gen))
print(next(squared_numbers_gen))
print(next(squared_numbers_gen))
```

**Вот некоторые способы применения генераторов и итераторов:**

* Постепенная обработка больших объемов данных, таких как чтение                         
  больших файлов или баз данных по мере необходимости.                        
* Ленивая загрузка данных из внешних источников.                       
* Генерация итерируемых последовательностей с определенными                                          
  правилами или условиями.                         
* Фильтрация или преобразование элементов в коллекции.                       
* Рекурсивные итерации без использования рекурсивных вызовов                                         
  функций, чтобы избежать переполнения стека.                          

**Задача:**                                         
Фильтрация данных из базы данных. Реализуйте итератор, который                                        
позволяет получать только те записи из базы данных, где возраст                                         
пользователя больше 18. ID этих пользователей записать в список                                         
`users_white_list` для передачи фронту                     

```python
database_data = [
    {"id": 1, "username": "user123", "email": "user123@example.com", "age": 25},
    {"id": 2, "username": "john_doe", "email": "johndoe@example.com", "age": 15},
    {"id": 3, "username": "emma_s", "email": "emma_s@example.com", "age": 42},
    {"id": 4, "username": "alex21", "email": "alex21@example.com", "age": 21},
    {"id": 5, "username": "lisa_smith", "email": "lisa.smith@example.com", "age": 30},
    {"id": 6, "username": "max_power", "email": "max_power@example.com", "age": 15},
    {"id": 7, "username": "sara_m", "email": "saram@example.com", "age": 28},
    {"id": 8, "username": "brian88", "email": "brian88@example.com", "age": 33},
    {"id": 9, "username": "julia_c", "email": "juliac@example.com", "age": 17},
    {"id": 10, "username": "sam99", "email": "sam99@example.com", "age": 14},
    {"id": 11, "username": "megan_ross", "email": "megan.ross@example.com", "age": 23},
    {"id": 12, "username": "mark_johnson", "email": "markjohnson@example.com", "age": 17},
    {"id": 13, "username": "amy_w", "email": "amy_w@example.com", "age": 18},
    {"id": 14, "username": "chris25", "email": "chris25@example.com", "age": 25},
    {"id": 15, "username": "natalie_g", "email": "natalieg@example.com", "age": 14},
    {"id": 16, "username": "michael_b", "email": "michaelb@example.com", "age": 19},
    {"id": 17, "username": "lucas34", "email": "lucas34@example.com", "age": 27},
    {"id": 18, "username": "olivia_smith", "email": "olivia.smith@example.com", "age": 14},
    {"id": 19, "username": "david_p", "email": "davidp@example.com", "age": 21},
    {"id": 20, "username": "sophie_w", "email": "sophiew@example.com", "age": 17},
    {"id": 21, "username": "ryan_miller", "email": "ryan.miller@example.com", "age": 35},
    {"id": 22, "username": "lily_g", "email": "lilyg@example.com", "age": 14},
    {"id": 23, "username": "patrick_s", "email": "patricks@example.com", "age": 37},
    {"id": 24, "username": "grace41", "email": "grace41@example.com", "age": 41},
    {"id": 25, "username": "daniel_h", "email": "danielh@example.com", "age": 15},
    {"id": 26, "username": "victoria99", "email": "victoria99@example.com", "age": 24},
    {"id": 27, "username": "jacob_t", "email": "jacobt@example.com", "age": 14},
    {"id": 28, "username": "sophia_c", "email": "sophiac@example.com", "age": 16},
    {"id": 29, "username": "andrew_j", "email": "andrewj@example.com", "age": 23},
    {"id": 30, "username": "emily_rose", "email": "emily.rose@example.com", "age": 17},
]
```

**Задача:**                                   
Генерация уникальных идентификаторов. Напишите генератор, который создает                                            
уникальные идентификаторы для объектов, добавляемых в систему. Уникальный                                                
идентификатор может быть строкой или числом и должен гарантировать                                                  
уникальность для каждого нового объекта.                            

---

# **Итеративные и генеративные выражения:**

`Итеративные и генеративные выражения` – это списковые включения для                              
упрощения читабельности и сокращения кода, такие включения можно                             
делать для списков, словарей, множеств, генераторов.                           

**Шаблон спискового включения:**                            

`[возвращаемое_значение цикл условие_не_обязательно]`

`Итеративное выражение` – это списковое включение, которое работает                             
уже с существующим итерируемым объектом.                        

Итеративные выражения используются для создания итерируемых объектов                             
с помощью синтаксиса списка (**list comprehension**).                                  
Они позволяют нам создавать последовательности                              
значений на основе других последовательностей или итерируемых объектов.                       

Итеративные выражения создают новую последовательность значений и могут                               
быть преобразованы в конкретные коллекции данных, такие как списки,                            
множества или кортежи.                              

**Генеративные выражения** используются для создания генераторов - итерируемых                                             
объектов, которые генерируют значения "лениво", по мере необходимости, без                                                  
хранения всех значений в памяти.                            

Генераторы используют ключевое слово `yield`, чтобы вернуть значения и                           
сохранить состояние выполнения функции.                                

Генеративные выражения возвращают генераторы, которые могут быть использованы                                                    
в циклах `for` или получать значения с помощью функции `next()`. Они особенно                                                      
полезны, когда требуется работать с большими объемами данных или                                              
генерировать значения по требованию без необходимости хранения всех                                                 
значений в памяти.                       

**Синтаксис итеративных и генеративных выражений в `Python` очень**                                       
**похож, но есть некоторые различия:**                            

1) **Синтаксис:**
   `Итеративное выражение:` Используется в квадратных скобках `[]` или                                         
   фигурных скобках `{}` для создания списка или множества.                            

`Генеративное выражение:` Используется в круглых скобках `()`                                                  
для создания генератора.                               

2) **Использование:**                              

`Итеративное выражение:` Создает новую коллекцию данных (список,                                                
множество и т. д.), которая может быть использована непосредственно.                                

`Генеративное выражение:` Создает генератор, который генерирует                                   
значения по требованию и сохраняет состояние выполнения функции.                                    

3) **Хранение значений**

`Итеративное выражение:` Создает и хранит все значения в памяти,                            
чтобы вернуть коллекцию данных целиком.                               

`Генеративное выражение:` Генерирует значения по мере необходимости,                           
сохраняя минимальное состояние в памяти.                           

4) **Использование в циклах:**                          

`Итеративное выражение:` Можно использовать напрямую в цикле `for`                                          
для итерации по всем элементам коллекции.                      

`Генеративное выражение:` Необходимо использовать функцию `next() `                                
или включить генератор в цикл `for` для получения значений.                            

5) **Возможности:**                       

`Итеративное выражение:` Позволяет преобразовывать и фильтровать                                          
значения, а также создавать новую коллекцию данных.                          

`Генеративное выражение:` Позволяет генерировать значения на лету                                         
и эффективно работать с большими объемами данных.                             

**Создание списка квадратов чисел:**                         
Через `list comprehension` создать список с числами, где каждое число                                            
возведено в квадрат                               

**Фильтрация списка четных чисел:**                           
Принять от пользователя числа через запятую                      
преобразовать их в список чисел                          
отфильтровать список через `list comprehansion`                             

**Вычисление суммы квадратов четных чисел:**                           
Есть список чисел, вычислить сумму его чётных чисел:                                               

```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```
---

**Область видимости переменных**

Все переменные, которые мы объявляем в функции, включая её                              
аргументы, являются локальными, а это значит, что обратиться                                
к ним можно только внутри функции, за функцией они не существуют.                           

Глобальные переменные объявляются внутри функции и работают, а                               
также хранят значения полученные в функции за ней, учтите что                               
использовать такие переменные не всегда безопасно.                             

**Всего есть 4 области видимости переменных:**                                  

`Build-in` - уровень сборки вашего питона                          
`Уровень файла` (глобальные переменные)                      
`Локальные переменные` (в блоке кода)                     
`Замкнутые переменные` переменные, закрытые внутри функции                          


```python
greeting = "Hello from the global scope"


def greet():
    greeting = "Hello from enclosing scope"

    def nested():
        # greeting = "Hello from the local scope"
        print(greeting)

    nested()


greet()
print(greeting)
```

# **Recursions**                                   


**Рекурсия** – это подход в программировании, при котором функция вызывает                           
сама себя. Любую рекурсивную функцию можно представить как цикл, а                         
цикл можно представить как рекурсию.                                

**Преимущества рекурсии:**                               

1) каждый новый вызов функции в функции начинается с чистого листа,                                      
   а значения из предыдущих вызовов отдаются в стек.                        
2) код, написанный через рекурсию читается проще. Решения выглядит лучше.                              

**Недостатки рекурсии:**                             

1) размер стека, которому проталкиваются элементы из каждого                               
   вызова не безграничен.                           
2) рекурсию трудно представить, если рекурсия спроектирована плохо,                                      
   она может убить ваше приложение или сильно его замедлить.                              

**Правила создания рекурсий:**                               

1) рекурсия не должна создавать больше чем 3000 слоев (вызовов)                       
2) у рекурсии всегда должно быть условие остановки                         
3) использовать рекурсию, для того чтобы решение становилось меньше и понятнее                       
4) использовать рекурсию, когда знаешь глубину вызов                       
5) если код читает другой человек, выбор в пользу рекурсии                                      
   (код красивее и понятнее)                             
6) если скорость не так важна выбор в пользу рекурсии                                 

```python
# пример рекурсии

def greeting(value: int) -> None:
    if value == 0:
        return 0
    print(f"Hello! This is recursion! {value}")
    greeting(value - 1)
```

**Основные принципы рекурсивных функций:**                           

`Базовый случай:` Рекурсивная функция всегда должна иметь **"базовый случай"**                                            
или **"условие выхода"**, которое определяет, когда рекурсия должна завершиться.                                      
Этот базовый случай обычно определяется так, чтобы функция не                                   
вызывала себя бесконечно.                                   

`Рекурсивный случай:` Это шаг, при котором функция вызывает саму себя с                                          
аргументами, которые приближают к базовому случаю. Это позволяет функции                                               
продолжать выполнение до тех пор, пока не будет достигнут базовый                                           
случай и рекурсия завершится.                             


**Рекурсия** - мощный инструмент в программировании, но её следует                                             
использовать осторожно, чтобы избежать бесконечных циклов и                              
излишних накладных расходов на память.                                  


# **Features of recursive functions in Python**                            

**Максимальная глубина рекурсии:**                              

В **Python** есть ограничение на максимальную глубину рекурсии, которое                          
определяется максимальным количеством вызовов функции, которые могут быть                         
вложены друг в друга. Это ограничение называется "**максимальной глубиной                            
стека**" (**maximum recursion depth**).                          

Значение максимальной глубины рекурсии зависит от конкретной версии                           
**Python** и его настроек. В стандартной настройке **Python** это значение                            
обычно составляет `1000` вызовов функций.                                   
При превышении максимальной глубины рекурсии **Python** вызовет                         
исключение `RecursionError`.                                  

```python
def infinity_recursion(a):
   return infinity_recursion(a + 1)
```

В **Python** можно переопределить максимальное количество вызовов рекурсии,                           
изменяя глубину стека с помощью функции `sys.setrecursionlimit()`. Однако                         
это не рекомендуется делать без веских причин, так как увеличение глубины                          
стека может привести к переполнению стека и ошибкам в работе программы.                            
Кроме того, стандартное значение глубины стека установлено на определенное                       
значение для обеспечения безопасности выполнения программ.                            

```python
import sys

new_limit = 500  # Новое значение глубины стека
sys.setrecursionlimit(new_limit)

# Теперь можно выполнять более глубокие рекурсивные вызовы
```

Вызов рекурсии может находиться не только в конце функции, но и в любом месте                         
функции, в зависимости от логики задачи. Передача управления рекурсивному                          
вызову в середине функции вполне допустима, и это может быть полезным                           
в некоторых сценариях.                          

```python
def countdown(n):
    print(n)
    if n > 0:
        countdown(n - 1)
    print("Выполнено для", n)

countdown(5)
```

```python
def factorial(n):
    if n == 0:
        return 1
    else:
        result = factorial(n - 1)
        return n * result

result = factorial(5)
print("Факториал равен:", result)
```

**Вычисление факториала числа.**
Напишите функцию, которая вычисляет факториал числа                       
n с использованием рекурсии.                


**Подсчет суммы элементов списка.**
Напишите функцию, которая рекурсивно вычисляет сумму                        
всех элементов списка целых чисел.                      

**Вычисление чисел Фибоначчи.**
Напишите функцию, которая рекурсивно вычисляет n-ное                             
число в последовательности Фибоначчи.                       
